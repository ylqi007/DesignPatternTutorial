## 单例模式
所谓类的单例模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个获取其对象实例的方法(静态方法)。

比如Hibernate的SessionFactory，它充当数据存储源的代理，并且负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这就会使用到单例模式。

**单例模式有八种方式**
1. 饿汉式(静态常量)
2. 饿汉式(静态代码块)
3. 懒汉式(线程不安全)
4. 懒汉式(线程安全，同步方法)
5. 懒汉式(线程安全，同步代码块)
6. 双重检查
7. 静态内部类
8. 枚举

### 1. 饿汉式(静态常量)
```java
class Singleton1 {
    // 1. 私有化构造器
    private Singleton1() {}

    // 2. 在本类内部创建对象实例
    private final static Singleton1 instance = new Singleton1();

    // 3. 提供一个公开的静态方法，返回实例
    public static Singleton1 getInstance() {
        return instance;
    }
}
```
* 优点：写法简单，在类加载的时候就完成了实例化。避免了线程同步的问题。
* 缺点：类加载时就完成实例化，没有达到Lazy Loading的效果。如果从始至终都为用到这个实例，则会造成内存浪费。
* 结论：这种单例模式可用，“可能”会造成内存浪费。


### 2. 饿汉式(静态代码块)
```java
class Singleton {
    // 2. 在本类内部创建对象实例
    private static Singleton instance;  // final?

    // 在静态代码块中，创建单例对象
    static {
        instance = new Singleton();
    }

    // 1. 私有化构造器，外部不能new
    private Singleton() {}

    // 3. 提供一个公开的静态方法，返回实例
    public static Singleton getInstance() {
        return instance;
    }
}
```
* 与饿汉式(静态变量 static)的方式其实类似，只不过将实例化的过程放在了静态代码块中，也是在类加载的时候就执行静态代码块中的代码，初始化类的实例。优缺点与静态变量方式一致。
* 结论：这种单例模式可用，但是可能造成内存浪费。